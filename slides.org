#+OPTIONS: num:nil

* What is Zetawar?

  - Turn based strategy browser game
  - Successful Kickstarter project
  - 100% Clojure and ClojureScript

* Goals

  - A game that can last (serverless)
  - Reference ClojureScript codebase
  - AI playground

* Demo

* Talk outline

  - Original architecture overview
  - New architecture overview
  - Original event system vs new event system
  - Original AI system vs new AI system
  - Optimizing Reagent and Posh
  - Writing an AI
  - Lessons learned
  - Future plans

* Original architecture

  #+BEGIN_SRC ditaa :file images/old_architecture.png
    +--------------------+
    |                    |     Events
    | Reagent Components +----------------+
    |                    |                |
    +--------------------+                |
              ^                           |
              |                           |
    +---------+----------+                |
    |                    |                |
    |       Tracks       |                v
    |                    |          +-----------+  +-------+
    +--------------------+          |           |  |       |
              ^                     | Callbacks +->|  AI   |
              |                     |           |  |       |
    +---------+----------+          +-----+-----+  +---+---+
    |                    |                |            |
    |        Posh        |                |            |
    |                    |                |            |
    +--------------------+                |            |
              ^                           |            |
              |                           |            |
    +---------+----------+                |            |
    | {s}                |   Transactions |            |
    |   DataScript DB    |<---------------+------------+
    |                    |
    +--------------------+
  #+END_SRC

  #+RESULTS:
  [[file:images/old_architecture.png]]


  #+BEGIN_NOTES
  - DataScript DB is the canonical data source
  - Views are rendered by Reagent (React)
  - Views are pure functions of the DB
  - View updates are automatic
  - Posh executes reactive DataScript queries
  - Tracks perform reactive transformations of query results
  - Tracks can be layered
  - Events and transactions are not reified
  - AI is an impure function called by the 'end-turn' handler
  #+END_NOTES

* New architecture

  TODO: add diagram

* Original architecture

  | Model            | DataScript            |
  | View             | Reagent (React)       |
  | Model → View     | Posh + Tracks         |
  | Event handling   | Callbacks             |
  | AI communication | Direct DB interaction |
  | Lifecycle        | Component             |

* New architecture

  | Model            | Unchanged                   |
  | View             | Unchanged                   |
  | Model → View     | Unchanged                   |
  | Event handling   | Reified events + core.async |
  | AI communication | Notifications and events    |
  | Lifecycle        | Integrant                   |

  #+BEGIN_NOTES
  Not covering Component vs Integrant in this talk.
  #+END_NOTES

* New event system
  
  - Events are data
  - Dispatched via core.async
  - Router sends events to handlers
  - Handlers are pure functions (mostly)
  - Handlers return
    - Transactions
    - Events
    - AI notifications

  #+BEGIN_NOTES
  Inspired by re-frame 0.9 event system.
  #+END_NOTES

* Old event handler

  #+BEGIN_SRC clojure
    (defn repair [conn ev]
      (let [db @conn
            [q r] (first (d/q '[:find ?q ?r
                                :where
                                [?a :app/selected-q ?q]
                                [?a :app/selected-r ?r]]
                              db))]
        (game/repair! conn (app/current-game-id db) q r)
        (clear-selection conn nil)))
  #+END_SRC

  #+BEGIN_NOTES
  - Connection (not DB) passed in
  - Repair executes transactions
  #+END_NOTES

* New event handler

  #+BEGIN_SRC clojure
    (defmethod router/handle-event ::repair-selected
      [{:as handler-ctx :keys [db]} _]
      (let [game (app/current-game db)
            cur-faction-color (game/current-faction-color game)
            [q r] (app/selected-hex db)]
        {:dispatch [[:zetawar.events.game/execute-action
                     {:action/type :action.type/repair-unit
                      :action/faction-color cur-faction-color
                      :action/q q
                      :action/r r}]
                    [::clear-selection]]}))
  #+END_SRC

  #+BEGIN_NOTES
  - Pure function
  - DB (value) passed in
  - Transactions and events returned
  #+END_NOTES

* Router

  - Calls handlers
  - Executes transactions
  - Sends AI notifications

* Router Loop

  #+BEGIN_SRC clojure
    (defn start [{:as router-ctx :keys [ev-chan]}]
      (go-loop [msg (<! ev-chan)]
        (when msg
          (try
            (log/debugf "Handling event: %s" (pr-str msg))
            (handle-event* router-ctx msg)
            (catch :default ex
              (js/Raven.captureException ex)
              (log/errorf ex "Error handling event: %s" (pr-str msg))))
          (recur (<! ev-chan)))))
  #+END_SRC

* Router Event Handling

  #+BEGIN_SRC clojure
    (defn handle-event* [{:as router-ctx :keys [conn ev-chan notify-chan]} msg]
      (let [ev-ctx (assoc router-ctx :db @conn)
            {:as ret :keys [tx]} (handle-event ev-ctx msg)]
        (log/tracef "Handler returned: %s" (pr-str ret))
        (when tx
          (log/debugf "Transacting: %s" (pr-str tx))
          (d/transact! conn tx))
        (doseq [new-msg (:dispatch ret)]
          (dispatch ev-chan new-msg))
        (doseq [notify-msg (:notify ret)]
          (players/notify notify-chan notify-msg))))
  #+END_SRC

* New event system advantages 
  
  - Validation
  - Testing
  - Logging
  - Error handling

* Original AI system

  #+BEGIN_SRC plantuml :file images/old_ai_sequence.png
  actor Player
  participant Zetawar
  database "Zetawar DB"
  participant AI
  Player -> Zetawar: End turn clicked
  Zetawar -> AI: Function call
  "Zetawar DB" <- AI: Action transaction
  #+END_SRC

  #+RESULTS:
  [[file:images/old_ai_sequence.png]]

* Original AI system
  
  - Direct game DB interaction
    - Requires running in the same process
    - Incompatible with new event system
  - No support for multiple AIs

* New AI system

  #+BEGIN_SRC plantuml :file images/new_ai_sequence.png
  actor Player
  database "Zetawar DB"
  participant Zetawar
  participant AI
  database "AI DB"
  Player -> Zetawar: End turn clicked
  Zetawar -> AI: Start notification
  Zetawar <- AI: Game state request
  Zetawar -> AI: Game state
  AI -> "AI DB": Game state
  Zetawar <- AI: Action
  Zetawar -> "Zetawar DB": Action transaction
  #+END_SRC

  #+RESULTS:
  [[file:images/new_ai_sequence.png]]


* New AI system

  - No direct game DB interaction
  - Game process sends notifications to AIs
  - AIs send events to game process
  - AIs maintain local copy of game state
  - Supports any number of players
  - Supports AI vs AI

* Other action format uses

  - Game logging and replay
  - Network games

* Optimizing Reagent and Posh

  - Queries logic often overlaps
    - Combine queries
    - Use Reagent to create views
  - Data changes at different rates

* Optimization examples

* What I've learned

* Future plans

* Making an AI
