#+OPTIONS: num:nil

* The Evolution of Zetawar
* What is Zetawar?

  - Turn based strategy browser game
  - Successful Kickstarter project
  - 100% ClojureScript

  #+BEGIN_NOTES
  - Kickstarter was successfully funded in July.
  - Some Clojure for static site rendering, but game logic is 100% ClojureScript.
  #+END_NOTES

* Goals

  - A game that can last (serverless)
  - Sizable reference ClojureScript codebase
  - Beginner friendly AI environment

  #+BEGIN_NOTES
  - Several similar games have been shut down essentially due to hosting or maintenance costs.
  - There aren't tons of large open source ClojureScript applications people can learn from.
  #+END_NOTES

* Demo

* Talk outline

  - Original architecture overview
  - New architecture overview
  - Original event system vs new event system
  - Original AI system vs new AI system
  - Optimizing Reagent and Posh
  - How to write an AI
  - Lessons learned
  - Future plans

* Original architecture

  #+BEGIN_SRC ditaa :file images/old_architecture.png
    +--------------------+
    |                    |  Event function calls
    | Reagent Components +-----------------------+
    |                    |                       |
    +--------------------+                       |
              ^                                  |
              |                                  |
    +---------+----------+                       |
    |                    |                       |
    |       Tracks       |                       v
    |                    |                 +-----------+  +-------+
    +--------------------+                 |           |  |       |
              ^                            | Callbacks +->|  AI   |
              |                            |           |  |       |
    +---------+----------+                 +-----+-----+  +---+---+
    |                    |                       |            |
    |        Posh        |                       |            |
    |                    |                       |            |
    +--------------------+                       |            |
              ^                                  |            |
              |                                  |            |
    +---------+----------+                       |            |
    | {s}                |   Calls to transact!  |            |
    |   DataScript DB    |<----------------------+------------+
    |                    |
    +--------------------+
  #+END_SRC

  #+RESULTS:
  [[file:images/old_architecture.png]]


  #+BEGIN_NOTES
  - DataScript is a fully relational in-memory DB
  - DataScript is the canonical data store
  - Views are rendered by Reagent (React)
  - Views are pure functions of the DB
  - View updates are automatic
  - Posh executes reactive DataScript queries
  - Tracks are a type of reaction in Reagent
  - Reactions are reactive functions of data and other reactions
  - Combination of Posh + Tracks is similar to in-memory mviews
  - Events and transactions are not reified
  - AI is an impure function called by the 'end-turn' handler
  #+END_NOTES

* New architecture

  #+BEGIN_SRC ditaa :file images/new_architecture.png
    +--------------------+
    |                    |       Event data 
    | Reagent Components +-------------------------+
    |                    |                         |
    +--------------------+                         |
              ^                                    |
              |                                    v
    +---------+----------+                 +----------------+ Notifications +------+
    |                    |                 |                +-------------->|      |
    |       Tracks       |              +->|     Router     |     Events    |  AI  |
    |                    |              |  |                |<--------------+      |
    +--------------------+    Events    |  +-------+--------+               +------+
              ^                 +       |          |
              |           Notifications |          v
    +---------+----------+              |  +----------------+
    |                    |              |  |                |
    |        Posh        |              +--+ Event Handlers |
    |                    |                 |                |
    +--------------------+                 +-------+--------+
              ^                                    |
              |                                    |
    +---------+----------+                         |
    | {s}                |     Transaction data    |
    |   DataScript DB    |<------------------------+
    |                    |
    +--------------------+
  #+END_SRC

  #+RESULTS:
  [[file:images/new_architecture.png]]

  #+BEGIN_NOTES
  - Not clear in diagram, but the router executes transactions.
  #+END_NOTES

* Original architecture

  | Model            | DataScript            |
  | View             | Reagent (React)       |
  | Model → View     | Posh + Tracks         |
  | Event handling   | Callbacks             |
  | AI communication | Direct DB interaction |
  | Lifecycle        | Component             |

* New architecture

  | Model            | Unchanged                   |
  | View             | Unchanged                   |
  | Model → View     | Unchanged                   |
  | Event handling   | Reified events + core.async |
  | AI communication | Notifications and events    |
  | Lifecycle        | Integrant                   |

  #+BEGIN_NOTES
  Not covering Component vs Integrant in this talk.
  #+END_NOTES

* New event system
  
  - Events are data
  - Dispatched via core.async
  - Router sends events to handlers
  - Handlers are pure functions (mostly)
  - Handlers return
    - Transactions
    - Events
    - AI notifications

  #+BEGIN_NOTES
  Inspired by re-frame 0.9 event system.
  #+END_NOTES

* Old event handler

  #+BEGIN_SRC clojure
    (defn repair [conn ev]
      (let [db @conn
            [q r] (first (d/q '[:find ?q ?r
                                :where
                                [?a :app/selected-q ?q]
                                [?a :app/selected-r ?r]]
                              db))]
        (game/repair! conn (app/current-game-id db) q r)
        (clear-selection conn nil)))
  #+END_SRC

  #+BEGIN_NOTES
  - Connection (not DB) passed in
  - Repair executes transactions
  #+END_NOTES

* New event handler

  #+BEGIN_SRC clojure
    (defmethod router/handle-event ::repair-selected
      [{:as handler-ctx :keys [db]} _]
      (let [game (app/current-game db)
            cur-faction-color (game/current-faction-color game)
            [q r] (app/selected-hex db)]
        {:dispatch [[:zetawar.events.game/execute-action
                     {:action/type :action.type/repair-unit
                      :action/faction-color cur-faction-color
                      :action/q q
                      :action/r r}]
                    [::clear-selection]]}))
  #+END_SRC

  #+BEGIN_NOTES
  - Pure function
  - DB (value) passed in
  - Events returned
  #+END_NOTES

* New event handler

  #+BEGIN_SRC clojure
    (defmethod router/handle-event ::execute-action
      [{:as handler-ctx :keys [db]} [_ action]]
      (let [game (app/current-game db)]
          ;; ...
          {:tx     (game/action-tx db game action)
           :notify [[:zetawar.players/apply-action :faction.color/all action]]})))
  #+END_SRC

  #+BEGIN_NOTES
  - Transactions and notifications returned
  #+END_NOTES

* Router

  - Calls handlers
  - Executes transactions
  - Sends AI notifications

* Router Loop

  #+BEGIN_SRC clojure
    (defn start [{:as router-ctx :keys [ev-chan]}]
      (go-loop [msg (<! ev-chan)]
        (when msg
          (try
            (log/debugf "Handling event: %s" (pr-str msg))
            (handle-event* router-ctx msg)
            (catch :default ex
              (js/Raven.captureException ex)
              (log/errorf ex "Error handling event: %s" (pr-str msg))))
          (recur (<! ev-chan)))))
  #+END_SRC

* Router Event Handling

  #+BEGIN_SRC clojure
    (defn handle-event* [{:as router-ctx :keys [conn ev-chan notify-chan]} msg]
      (let [ev-ctx (assoc router-ctx :db @conn)
            {:as ret :keys [tx]} (handle-event ev-ctx msg)]
        (log/tracef "Handler returned: %s" (pr-str ret))
        (when tx
          (log/debugf "Transacting: %s" (pr-str tx))
          (d/transact! conn tx))
        (doseq [new-msg (:dispatch ret)]
          (dispatch ev-chan new-msg))
        (doseq [notify-msg (:notify ret)]
          (players/notify notify-chan notify-msg))))
  #+END_SRC

* New event system advantages 
  
  - Validation
  - Testing
  - Logging
  - Error handling

* Original AI system

  #+BEGIN_SRC plantuml :file images/old_ai_sequence.png
  actor Player
  participant Zetawar
  database "Zetawar DB"
  participant AI
  Player -> Zetawar: End turn clicked
  Zetawar -> AI: Call AI function
  group AI function
    "Zetawar DB" <- AI: Action transaction
    "Zetawar DB" <- AI: Action transaction
    rnote over "Zetawar DB", AI
       etc.
    end note
  end
  #+END_SRC

  #+RESULTS:
  [[file:images/old_ai_sequence.png]]


  #+BEGIN_NOTES
  - AI directly interacts with game DB
  - AI is one big side effect
  - AI must run in the same process
  - Hard to integrate well with new event system
    - Due to side effects
  - Lots of subtle problems
    - Hard to pause for rendering
    - Hard to support stepping through moves
  #+END_NOTES

* New AI system 

  #+BEGIN_SRC plantuml :file images/new_ai_sequence.png
  actor Player
  database "Zetawar DB"
  participant Zetawar
  participant AI
  database "AI DB"
  Player -> Zetawar: End turn clicked
  Zetawar -> AI: Start turn notification
  Zetawar <- AI: Game state request
  Zetawar -> AI: Game state
  AI -> "AI DB": Game state
  Zetawar <- AI: Action event
  Zetawar -> "Zetawar DB": Action transaction
  rnote over Zetawar, AI
      Game state request and action cycle repeats
  end note
  #+END_SRC

  #+RESULTS:
  [[file:images/new_ai_sequence.png]]


  #+BEGIN_NOTES
  - No direct AI interaction with game DB
  - Communication is message based
    - Game sends notifications
    - AIs send events
    - Game actions are described by data
  - AIs maintain local copy of game state
    - Can be update incrementally, but isn't yet
  - AI is logically a pure function
    - Side effects happen, but they're internal to the AI
  - Supports moving AI to another process
  - Easier to implement action stepping
  - Rendering pauses can happen in the router
  #+END_NOTES

* Other action format uses

  - Game logging and replay
  - Network games

* Optimizing Reagent and Posh

  - Queries logic often overlaps
    - Combine queries
    - Use Reagent to create views
  - Different data changes at different rates
    - Use separate queries for fast vs slow data
    - Query slow data in bulk
    - Query fast data at granularity of change

  #+BEGIN_NOTES
  - Had a hard time decided where to put this in the presentation. 
  - Example: Map changes infrequently, but units change frequently.
  #+END_NOTES

* Optimization example

  #+BEGIN_SRC clojure
    (deftrack terrains [conn]
      (let [map-eid' @(game-map-eid conn)]
        (:map/terrains
         @(posh/pull conn [{:map/terrains terrain-pull}]
                     map-eid'))))

    (deftrack map-width [conn]
      (or (->> @(terrains conn)
               (map :terrain/q)
               (apply max))
          0))
  #+END_SRC

* High level AI interface

  #+BEGIN_SRC plantuml :file images/ai_interface.png
  start

  while (actors to score?)
    :score actor;
  endwhile
  :pick actor with highest score;
  while (actions to score?)
    :score actions;
  endwhile
  :pick action with highest score;
  :perform action;

  stop
  #+END_SRC

  #+RESULTS:
  [[file:images/ai_interface.png]]

  #+BEGIN_NOTES
  - Actors = base and bases
  - One action picked per iteration
  - Process repeats until it returns no actions
  #+END_NOTES

* Making an AI

  - Implement actor (base/unit) score function
  - Implement base action score function
  - Implement unit action chooser
  - Profit!

* AI Example

  #+BEGIN_SRC clojure
    (defn score-actor [db game actor actor-ctx]
      (cond
        (game/unit? actor) (rand-int 100)
        (game/base? actor) (+ (rand-int 100) 100)))

    (defn score-base-action [db game base action-ctx action]
      (rand-int 200))
  #+END_SRC

* AI Example

  #+BEGIN_SRC clojure
    (defn mk-unit-action-ctx [db game actor-ctx unit]
      (assoc actor-ctx :closest-base (game/closest-capturable-base db game unit)))

    (defn score-unit-action [db game unit action-ctx action]
      (let [{:keys [closest-base]} action-ctx]
        (case (:action/type action)
          :action.type/capture-base
          200

          :action.type/attack-unit
          100

          :action.type/move-unit
          (let [[base-q base-r] (game/terrain-hex closest-base)
                {:keys [action/to-q action/to-r]} action
                base-distance (hex/distance base-q base-r to-q to-r)]
            (- 100 base-distance))

          0)))
  #+END_SRC
 
* Lessons learned

  TODO: add more content
   
  - Relational model++
  - DataScript is fast enough
  - Lots of room for optimization

* Future plans
  
  TODO: add more content

  - Engage with the community
  - Add more AI helper functions
  - Spec data format

* Q and A

  TODO: add links
