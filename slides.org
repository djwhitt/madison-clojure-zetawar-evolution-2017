#+OPTIONS: num:nil

* What is Zetawar?

  - Turn based strategy browser game
  - Successful Kickstarter project
  - 100% Clojure and ClojureScript

* Demo

* Goals

  - A game that can survive (serverless)
  - Reference ClojureScript codebase
  - AI playground

* Original architecture

  #+BEGIN_SRC ditaa :file images/old_architecture.png
    +--------------------+
    |                    |     Events
    | Reagent Components +----------------+
    |                    |                |
    +--------------------+                |
              ^                           |
              |                           |
    +---------+----------+                |
    |                    |                |
    |       Tracks       |                v
    |                    |          +-----------+  +-------+
    +--------------------+          |           |  |       |
              ^                     | Callbacks +->|  AI   |
              |                     |           |  |       |
    +---------+----------+          +-----+-----+  +---+---+
    |                    |                |            |
    |        Posh        |                |            |
    |                    |                |            |
    +--------------------+                |            |
              ^                           |            |
              |                           |            |
    +---------+----------+                |            |
    | {s}                |   Transactions |            |
    |   DataScript DB    |<---------------+------------+
    |                    |
    +--------------------+
  #+END_SRC

  #+RESULTS:
  [[file:images/old_architecture.png]]


  #+BEGIN_NOTES
  - DataScript DB is the canonical data source
  - Views are rendered by Reagent (React)
  - Views are pure functions of the DB
  - View updates are automatic
  - Posh executes reactive DataScript queries
  - Tracks perform reactive transformations of query results
  - Tracks can be layered
  - Events and transactions are not reified
  - AI is an impure function called by the 'end-turn' handler
  #+END_NOTES

* Original architecture
  
  | Model          | DataScript            |
  | View           | Reagent (React)       |
  | Model → View   | Posh + Tracks         |
  | Event handling | Callbacks             |
  | AI interface   | Direct DB interaction |
  | Lifecycle      | Component             |

* New architecture

  TODO: add diagram

* New architecture

  | Model          | Unchanged                   |
  | View           | Unchanged                   |
  | Model → View   | Unchanged                   |
  | Event handling | Reified events + core.async |
  | AI interface   | Notifications and commands  |
  | Lifecycle      | Integrant                   |

  #+BEGIN_NOTES
  Not covering Integrant change in this talk.
  #+END_NOTES

* New event system
  
  - Events are data
  - Dispatched via core.async
  - Router sends events to handlers
  - Handlers are pure functions (mostly)
  - Handlers return
    - Transactions
    - Events
    - AI notifications

  #+BEGIN_NOTES
  Inspired by re-frame 0.9 event system.
  #+END_NOTES

* Old event handler

  #+BEGIN_SRC clojure
    (defn repair [conn ev]
      (let [db @conn
            [q r] (first (d/q '[:find ?q ?r
                                :where
                                [?a :app/selected-q ?q]
                                [?a :app/selected-r ?r]]
                              db))]
        (game/repair! conn (app/current-game-id db) q r)
        (clear-selection conn nil)))
  #+END_SRC

  #+BEGIN_NOTES
  - Connection (not DB) passed in
  - Repair executes transactions
  #+END_NOTES

* New event handler

  #+BEGIN_SRC clojure
    (defmethod router/handle-event ::repair-selected
      [{:as handler-ctx :keys [db]} _]
      (let [game (app/current-game db)
            cur-faction-color (game/current-faction-color game)
            [q r] (app/selected-hex db)]
        {:dispatch [[:zetawar.events.game/execute-action
                     {:action/type :action.type/repair-unit
                      :action/faction-color cur-faction-color
                      :action/q q
                      :action/r r}]
                    [::clear-selection]]}))
  #+END_SRC

  #+BEGIN_NOTES
  - Pure function
  - DB (value) passed in
  - Transactions and events returned
  #+END_NOTES

* Router

  - Calls handlers
  - Executes transactions
  - Sends AI notifications

* Router
  
  TODO: add code

* New event system advantages 
  
  - Validation
  - Testing
  - Logging
  - Error handling

* Original AI system

  #+BEGIN_SRC plantuml :file images/old_ai_sequence.png
  actor Player
  participant Zetawar
  database "Zetawar DB"
  participant AI
  Player -> Zetawar: End turn clicked
  Zetawar -> AI: Function call
  "Zetawar DB" <- AI: Action transaction
  #+END_SRC

  #+RESULTS:
  [[file:images/old_ai_sequence.png]]

* Original AI system
  
  - Direct game DB interaction
    - Requires running in the same process
    - Incompatible with new event system
  - No support for multiple AIs

* New AI system

  #+BEGIN_SRC plantuml :file images/new_ai_sequence.png
  actor Player
  database "Zetawar DB"
  participant Zetawar
  participant AI
  database "AI DB"
  Player -> Zetawar: End turn clicked
  Zetawar -> AI: Start notification
  Zetawar <- AI: Game state request
  Zetawar -> AI: Game state
  AI -> "AI DB": Game state
  Zetawar <- AI: Action
  Zetawar -> "Zetawar DB": Action transaction
  #+END_SRC

  #+RESULTS:
  [[file:images/new_ai_sequence.png]]


* New AI system

  - No direct game DB interaction
  - Game process sends notifications to AIs
  - AIs send events to game process
  - AIs maintain local copy of game state
  - Supports any number of players
  - Supports AI vs AI

* Other action format uses

  - Game logging and replay
  - Network games

* Optimizing Reagent and Posh

  - Queries logic often overlaps
    - Combine queries
    - Use Reagent to create views
  - Data changes at different rates

* Optimization examples

* What I've learned

* Future plans

* Making an AI
