#+OPTIONS: num:nil

* What is Zetawar?

  - Turn based strategy browser game
  - Successful Kickstarter project
  - 100% Clojure and ClojureScript

* Goals

  - A game that can last (serverless)
  - Reference ClojureScript codebase
  - AI playground

* Demo

* Talk outline

  - Original architecture overview
  - New architecture overview
  - Original event system vs new event system
  - Original AI system vs new AI system
  - Optimizing Reagent and Posh
  - Writing an AI
  - Lessons learned
  - Future plans

* Original architecture

  #+BEGIN_SRC ditaa :file images/old_architecture.png
    +--------------------+
    |                    |     Events
    | Reagent Components +----------------+
    |                    |                |
    +--------------------+                |
              ^                           |
              |                           |
    +---------+----------+                |
    |                    |                |
    |       Tracks       |                v
    |                    |          +-----------+  +-------+
    +--------------------+          |           |  |       |
              ^                     | Callbacks +->|  AI   |
              |                     |           |  |       |
    +---------+----------+          +-----+-----+  +---+---+
    |                    |                |            |
    |        Posh        |                |            |
    |                    |                |            |
    +--------------------+                |            |
              ^                           |            |
              |                           |            |
    +---------+----------+                |            |
    | {s}                |   Transactions |            |
    |   DataScript DB    |<---------------+------------+
    |                    |
    +--------------------+
  #+END_SRC

  #+RESULTS:
  [[file:images/old_architecture.png]]


  #+BEGIN_NOTES
  - DataScript DB is the canonical data source
  - Views are rendered by Reagent (React)
  - Views are pure functions of the DB
  - View updates are automatic
  - Posh executes reactive DataScript queries
  - Tracks perform reactive transformations of query results
  - Tracks can be layered
  - Events and transactions are not reified
  - AI is an impure function called by the 'end-turn' handler
  #+END_NOTES

* New architecture

  #+BEGIN_SRC ditaa :file images/new_architecture.png
    +--------------------+
    |                    |          Events
    | Reagent Components +-------------------------+
    |                    |                         |
    +--------------------+                         |
              ^                                    |
              |                                    v
    +---------+----------+                 +----------------+ Notifications +------+
    |                    |                 |                +-------------->|      |
    |       Tracks       |              +->|     Router     |     Events    |  AI  |
    |                    |              |  |                |<--------------+      |
    +--------------------+    Events    |  +-------+--------+               +------+
              ^                 +       |          |
              |           Notifications |          v
    +---------+----------+              |  +----------------+
    |                    |              |  |                |
    |        Posh        |              +--+ Event Handlers |
    |                    |                 |                |
    +--------------------+                 +-------+--------+
              ^                                    |
              |                                    |
    +---------+----------+                         |
    | {s}                |      Transactions       |
    |   DataScript DB    |<------------------------+
    |                    |
    +--------------------+
  #+END_SRC

  #+RESULTS:
  [[file:images/new_architecture.png]]

* Original architecture

  | Model            | DataScript            |
  | View             | Reagent (React)       |
  | Model → View     | Posh + Tracks         |
  | Event handling   | Callbacks             |
  | AI communication | Direct DB interaction |
  | Lifecycle        | Component             |

* New architecture

  | Model            | Unchanged                   |
  | View             | Unchanged                   |
  | Model → View     | Unchanged                   |
  | Event handling   | Reified events + core.async |
  | AI communication | Notifications and events    |
  | Lifecycle        | Integrant                   |

  #+BEGIN_NOTES
  Not covering Component vs Integrant in this talk.
  #+END_NOTES

* New event system
  
  - Events are data
  - Dispatched via core.async
  - Router sends events to handlers
  - Handlers are pure functions (mostly)
  - Handlers return
    - Transactions
    - Events
    - AI notifications

  #+BEGIN_NOTES
  Inspired by re-frame 0.9 event system.
  #+END_NOTES

* Old event handler

  #+BEGIN_SRC clojure
    (defn repair [conn ev]
      (let [db @conn
            [q r] (first (d/q '[:find ?q ?r
                                :where
                                [?a :app/selected-q ?q]
                                [?a :app/selected-r ?r]]
                              db))]
        (game/repair! conn (app/current-game-id db) q r)
        (clear-selection conn nil)))
  #+END_SRC

  #+BEGIN_NOTES
  - Connection (not DB) passed in
  - Repair executes transactions
  #+END_NOTES

* New event handler

  #+BEGIN_SRC clojure
    (defmethod router/handle-event ::repair-selected
      [{:as handler-ctx :keys [db]} _]
      (let [game (app/current-game db)
            cur-faction-color (game/current-faction-color game)
            [q r] (app/selected-hex db)]
        {:dispatch [[:zetawar.events.game/execute-action
                     {:action/type :action.type/repair-unit
                      :action/faction-color cur-faction-color
                      :action/q q
                      :action/r r}]
                    [::clear-selection]]}))
  #+END_SRC

  #+BEGIN_NOTES
  - Pure function
  - DB (value) passed in
  - Transactions and events returned
  #+END_NOTES

* Router

  - Calls handlers
  - Executes transactions
  - Sends AI notifications

* Router Loop

  #+BEGIN_SRC clojure
    (defn start [{:as router-ctx :keys [ev-chan]}]
      (go-loop [msg (<! ev-chan)]
        (when msg
          (try
            (log/debugf "Handling event: %s" (pr-str msg))
            (handle-event* router-ctx msg)
            (catch :default ex
              (js/Raven.captureException ex)
              (log/errorf ex "Error handling event: %s" (pr-str msg))))
          (recur (<! ev-chan)))))
  #+END_SRC

* Router Event Handling

  #+BEGIN_SRC clojure
    (defn handle-event* [{:as router-ctx :keys [conn ev-chan notify-chan]} msg]
      (let [ev-ctx (assoc router-ctx :db @conn)
            {:as ret :keys [tx]} (handle-event ev-ctx msg)]
        (log/tracef "Handler returned: %s" (pr-str ret))
        (when tx
          (log/debugf "Transacting: %s" (pr-str tx))
          (d/transact! conn tx))
        (doseq [new-msg (:dispatch ret)]
          (dispatch ev-chan new-msg))
        (doseq [notify-msg (:notify ret)]
          (players/notify notify-chan notify-msg))))
  #+END_SRC

* New event system advantages 
  
  - Validation
  - Testing
  - Logging
  - Error handling

* Original AI system

  #+BEGIN_SRC plantuml :file images/old_ai_sequence.png
  actor Player
  participant Zetawar
  database "Zetawar DB"
  participant AI
  Player -> Zetawar: End turn clicked
  Zetawar -> AI: Function call
  "Zetawar DB" <- AI: Action transaction
  #+END_SRC

  #+RESULTS:
  [[file:images/old_ai_sequence.png]]

* Original AI system
  
  - Direct game DB interaction
    - Requires running in the same process
    - Incompatible with new event system
  - No support for multiple AIs

* New AI system 

  #+BEGIN_SRC plantuml :file images/new_ai_sequence.png
  actor Player
  database "Zetawar DB"
  participant Zetawar
  participant AI
  database "AI DB"
  Player -> Zetawar: End turn clicked
  Zetawar -> AI: Start turn notification
  Zetawar <- AI: Game state request
  Zetawar -> AI: Game state
  AI -> "AI DB": Game state
  Zetawar <- AI: Action
  Zetawar -> "Zetawar DB": Action transaction
  #+END_SRC

  #+RESULTS:
  [[file:images/new_ai_sequence.png]]


* New AI system

  - No direct game DB interaction
  - Game process sends notifications to AIs
  - AIs send events to game process
  - AIs maintain local copy of game state
  - Supports any number of players
  - Supports AI vs AI

* Other action format uses

  - Game logging and replay
  - Network games

* Optimizing Reagent and Posh

  - Queries logic often overlaps
    - Combine queries
    - Use Reagent to create views
  - Data changes at different rates
    - Use separate queries for fast vs slow data
    - Query slow data in bulk
    - Query fast data at granularity of change

  #+BEGIN_NOTES
  Example: map changes infrequently units change frequently
  #+END_NOTES

* Optimization example

  #+BEGIN_SRC clojure
    (deftrack terrains [conn]
      (let [map-eid' @(game-map-eid conn)]
        (:map/terrains
         @(posh/pull conn [{:map/terrains terrain-pull}]
                     map-eid'))))

    (deftrack map-width [conn]
      (or (->> @(terrains conn)
               (map :terrain/q)
               (apply max))
          0))
  #+END_SRC

* High level AI interface

  #+BEGIN_SRC plantuml :file images/ai_interface.png
  start

  while (actors to score?)
    :score actor;
  endwhile
  :pick actor with highest score;
  while (actions to score?)
    :score actions;
  endwhile
  :pick action with highest score;
  :perform action;

  stop
  #+END_SRC

  #+RESULTS:
  [[file:images/ai_interface.png]]

  #+BEGIN_NOTES
  - Outer loop (while actionable actors?) is missing to fit on slide.
  #+END_NOTES

* Making an AI

  - Implement actor (base/unit) score function
  - Implement base action score function
  - Implement unit action chooser
  - Profit!

* AI Example

  #+BEGIN_SRC clojure
    (defn score-actor [db game actor actor-ctx]
      (cond
        (game/unit? actor) (rand-int 100)
        (game/base? actor) (+ (rand-int 100) 100)))

    (defn score-base-action [db game base action-ctx action]
      (rand-int 200))
  #+END_SRC

* AI Example

  #+BEGIN_SRC clojure
    (defn mk-unit-action-ctx [db game actor-ctx unit]
      (assoc actor-ctx :closest-base (game/closest-capturable-base db game unit)))

    (defn score-unit-action [db game unit action-ctx action]
      (let [{:keys [closest-base]} action-ctx]
        (case (:action/type action)
          :action.type/capture-base
          200

          :action.type/attack-unit
          100

          :action.type/move-unit
          (let [[base-q base-r] (game/terrain-hex closest-base)
                {:keys [action/to-q action/to-r]} action
                base-distance (hex/distance base-q base-r to-q to-r)]
            (- 100 base-distance))

          0)))
  #+END_SRC
 
* Lessons learned
   
  TODO: add more content

  - The relational still rocks
  - DataScript is fast enough

* Future plans

  TODO: add more content

  - Engage with the community more
  - Add more AI helper functions
